---
title: Linux内核之系统调用
date: 2018-04-04 14:37:21
tags:
	- Linux内核

---



Linux内核的调用梳理，是比较少的。只有250多个 。比起其他系统的上千个，真的是很少。

我觉得这个理念，跟RISC架构有点像，用更少的指令去组合出复杂的指令，简化系统。

我们看一个简单的系统调用的定义。

```
SYSCALL_DEFINE0(getpid)
{
	return task_tgid_vnr(current);
}
```

这个展开后的效果是：

```
asmlinkage long sys_getpid(void)
```

asmlinkage是一个限定词，是编译指令，通知编译器只能从栈里面提取这个函数的参数。

所有的系统调用都需要使用这个限定词。

返回类型是long类型，为了保证32位和64位的兼容性。在用户空间，返回的是int，在内核空间是long。

# 系统调用号

在linux里，每一个系统调用都被赋予了一个编号。一一对应的。

这个编码很重要，一旦分配，就不会再改动。

一个被去掉的系统调用，它的编码也要留着，不能回收。

# 系统调用的实现

新增一个系统调用不难，但是不建议做。

