---
title: lwip之《LwIP协议栈源码详解》笔记
date: 2018-04-26 21:30:07
tags:
	- lwip

---



老衲五木的《LwIP协议栈源码详解》写得很好。我学习一下，总结记录下来。



# 14 tcp建立和断开

tcp如何保证可靠性。
1、应用层的数据被切分成 tcp自己认为合适的大小。
2、发送一段数据后，tcp启动一个定时器，等待对方确认收到。
3、ip层的包可能会乱序，tcp对报文进行重排。
4、ip数据包可能会重复，tcp还需要把重复的包丢掉。



注意 TCP 状态转换图中的双方同时打开的情况，即从 LISTEN 状态到 SYN_SENT 状态，
SYN_SENT 状态到 SYN_RCVD 状态，没有被实现。许多其他 TCP/IP 实现，如 BSD 中也是
这样的，没有实现这部分功能。因为在实际应用中这种情况几乎不可见，所以实现并没有严
格按照协议来实行。

# 22 tcp超时与重传 

跟超时时间密切相关的是RTT的估算。
RTT是某个字节数据被发送出去到收到对方回复确认的时间间隔。
这个是一直在变化的。
所以，协议栈应该跟踪这个变化，并且调整超时重传的时间值。
在某段时间内，发送方可能连续发送多个数据包。
但是，发送方只能选择一个发送包启动定时器。
协议栈利用一些优化算法来平滑RTT的值。
tcp_output从unsent队列上取下第一个数据段，然后调用函数tcp_output_segment把数据段发送出去。

发送完成后，tcp_output把这个数据包挂到unacked队列上去。

在RTT变化很大的时候，基于均值和方差来计算RTO时间，效果会比较好。



# 23 tcp慢启动与拥塞控制



讨论都假定A的客户端，B是服务端。
一般在建立连接的时候，A向B发起连接，B在ack的时候，就把自己的窗口大小告诉A了。
A拿到窗口大小后，不会一下子就发送这么多的数据，这就是慢启动。
如果直接按窗口大小发送数据，可能带来的问题是：
中间路由转发导致的拥塞，导致网络吞吐量不稳定。



慢启动，可以参考生活实际经验来帮助理解，先小心一点，进行试探，如果真的网络通畅，我们再全力收发。

避免出现一开始猛发，然后发现不行，再降低。

慢启动是靠tcp_pcb里的cwnd（拥塞窗口）来帮助实现的。

cwnd一开始是1，然后是2，再是4，按指数递增。

慢启动算法和拥塞避免算法是一起实现的。

tcp_pcb里还有一个成员，ssthresh。（Slow Start Threshold）。慢启动门限。



# 24 tcp快速恢复重传和Nagle算法

当收到一个乱序报文段的时候，会被挂到tcp_pcb里的ooseg队列上。



# 26 tcp定时器

tcp为每个连接配备了7个定时器。

1、连接建立定时器。A向B发送了SYN，在75秒内没有收到ACK，就会终止连接。

2、重传定时器。

3、延迟ACK 。可以把ACK放到一个带数据的tcp报文里发回去，这个叫“捎带确认”。如果200ms内，这个ACK还没有被捎带出去，就要马上发一个专门的ACK报文来确认。

4、坚持定时器。

5、保活定时器。

6、FIN_WAIT_2定时器。某个连接从FIN_WAIT_1变为FIN_WAIT_2，这时候开始启动这个定时器，时间是10分钟。超时后，再设置为75秒，再超时，就关闭连接。

7、TIME_WAIT定时器。一般也叫2MSL定时器。MSL是最大报文生存时间。是这个时间的2倍。定时器一般设置为1分钟，超时后，tcp_pcb被删除。对应的端口号可以被再次使用。

上面这7个定时器，坚持定时器用persist_cnt字段，重传定时器用rtime字段，其余的5个除了延迟ACK都用rtime字段计数。之所以可以共用，是因为分别是在TCP的4种不同的状态。

延迟ACK是用系统的250ms周期来做的。

lwip包括2个定时器函数：

一个是250ms，叫fast_tmr。

一个是500ms。叫slow_tmr。





