---
title: lwip之基本了解
date: 2017-11-02 23:54:29
tags:
	- lwip
	- 网络

---





# 1. 内存管理

lwip的动态内存管理分为3种：

1、C运行时自带的内存分配策略。

2、动态内存堆（HEAP）分配策略。

3、动态内存池（POOL）分配策略。

其中HEAP策略和C运行时的内存分配很相似。是lwip模仿C运行时分配策略做的。1和2只能二选一。

在RT-Thread里，用了第一种策略。

pool也是用了的。



# 2. api分类

从lwip源代码的doc目录下来看，里面的rawapi.txt文件里有描述。

lwip提供了3种API。

1、raw API。比较底层的。基于回调来做的。tcp_new、tcp_bind这些函数接口。

2、netconn开头的api接口。和socket方式的很像。

3、bsd风格是socket接口。基于netconn接口封装的。

现在重点看看raw api的用法。

用raw API的场景：

1、运行应用代码和tcpip代码更好地融合。

2、程序执行基于回调和事件。

3、tcpip代码和应用代码在同一个线程。

优点：

1、执行速度快一些。

2、内存占用小一些。

缺点：

1、写出来的代码不是很好懂。



# 3.pbuf

在协议栈中移动的数据包，无疑是整个系统中内存管理最重要的部分。

lwip对数据包处理有个原则：数据尽量避免拷贝行为。拷贝会浪费内存和时间。

pbuf被用来担当这个重任。

这个结构体不复杂，只有7个成员。分别是下一个指针、数据指针、总长度、当前长度、类型、flags、ref

1、要下一个指针，因为一个包，可能要多个pbuf来能装得下。

2、数据指针。可以是指向在ram里的东西，也可以是指向rom里东西。

3、tot_len和len。在链表里的第一个pbuf，tot_len表示后面的总长度。而最后一个pbuf的tot_len和len相等。

4、ref。初始化的时候，ref为1，当有其他的pbuf的next指针指向改pbuf的时候，该pbuf的ref加1，要删除某个pubf，要它的ref为1，才能删除。

## 3.1 pbuf的分类

有4种：

1、PBUF_RAM

这种最常见。是malloc出来的内存。一般是往外发的时候，用的是这种。

分配处理的pbuf结构体和payload是在一个连续的内存上。中间隔了一个offset（可以是0）。



2、PBUF_ROM

在内存里分配一个pbuf结构体，但是不分配payload占用的内存。这个是最关键的一点。



3、PBUF_POOL

这个一般是接收数据时用的。因为申请很快。



4、PBUF_REF

和PBUF_ROM类似。



# 4. netif结构体

netif用来描述网卡。它处于四层结构的最底层链路层。从这里开始分析比较好。

结构体也不复杂。重点注意一下output和linkoutput两个函数的区别。

linkoutput是在ARP模块里使用的，这就是主要区别。



# 5. arp

arp是地址解析协议的缩写。

任何网络通信都是基于底层硬件链路的。底层链路都有自己的一套寻址机制。

对于以太网，这个寻址就是通过48bit的mac地址来做的。

arp表示就是mac地址和ip地址的对应关系表。

arp协议的核心就是arp缓存表。

以太网帧类型，我们厂常见的就是两种，IP包和ARP包。IP包对应0x0806，ARP包对应0x0800 。



# 6. ip层输入



# 7. ip的分片重组

老版本的lwip没有实现这个功能。不过，lwip一般用在嵌入式产品里，数据量不大，不支持这个功能也没有大的关系。

较新的版本已经支持这个功能了。但是实现方式与标准协议中差别较大。lwip处理得更简单。但是因此使得代码比较难懂了。



# 8. ICMP协议

现在开始讲传输层的东西。ICMP是简单的传输层协议。



# 9. TCP部分



## 9.1 tcp连接与断开

tcp部分是lwip里最复杂的部分，占据了大概一半的代码量。

tcp通过这些手段来保证可靠性：

1、应用数据被分割成tcp认为最适合发送的数据块大小。

2、当tcp发出一段数据后，会启动一个定时器，在定时期限内，如果不能收到对方的确认，则会重发数据。

3、tcp收到对方发来的数据后，会回复一个确认，但是这个确认不是马上发的，要等几百毫秒。

4、tcp将保持数据头部和数据校验和，如果发现数据有错误，就不确认，然后对方发现超时了，就会重新发送。

5、ip数据包可能会乱序，tcp会对数据进行重新排序，保证把数据正确地交给应用层。

6、ip数据包可能还会重复，tcp要能够识别并且把重复数据丢掉。

## 9.2 tcp相关函数说明

tcp_new：

malloc了一块内存，初始化好各个值。

tcp_bind：

把tcp的pcb挂到全局链表tcp_bound_pcbs上。

tcp_listen：

把tcp的PCB从tcp_bound_pcbs上取下来，挂到全局tcp_listen_pcbs上。

通过tcp_input和tcp_listen_input函数处理后，当tcp被连接上后，tcp的pcb又被挂到了tcp_active_pcbs上了。

