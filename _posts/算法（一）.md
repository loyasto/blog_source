---
title: 算法（一）
date: 2018-03-09 15:28:36
tags:
	- 算法
typora-root-url: ..\
---



在面试中，总是免不了碰到算法题。现在我把基本的算法梳理一遍。

最基础的算法就是排序。就从排序开始看。

目前总共有多少种排序算法，相互的关系又是什么呢？

总共11种常见排序算法，分类如下。

比较类的排序，归并排序是最快的。

![排序算法分类](/images/排序算法分类.png)

我们从左边开始看。

交换类排序的基本思路是：

```
两两比较，交换不满足要求的，直到全部满足要求为止。
```

下面代码我都按升序排列。

# 冒泡排序

冒泡排序算法是最直观，最简单的排序。也是效率最低的排序。

```
#include <stdio.h>

void bubble_sort(int a[], int n)
{
    int i,j,tmp;
    for(i=0; i<n-1; i++) {
        for(j=0; j<n-1-i; j++) {
            if(a[j] > a[j+1]) {
                tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                printf("i:%d \n", i);
                print_result1(a,n);
            }
        }
    }
}

void print_result1(int a[], int n)
{
    int i=0;
    //printf("\n");
    for(i=0; i<n; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
}
void print_result(int a[], int n)
{
    int i=0;
    printf("----result------------\n");
    for(i=0; i<n; i++) {
        printf("%d ", a[i]);
    }
    printf("\n-----------------\n");
}
void main()
{
    int a[5] = {5,2,4,3,1};
    bubble_sort(a,5);
    print_result(a, 5);
    
}
```

运行效果：

```
pi@raspberrypi:~/test/c-test$ ./a.out 
i:0 
2 5 4 3 1 
i:0 
2 4 5 3 1 
i:0 
2 4 3 5 1 
i:0 
2 4 3 1 5 
i:1 
2 3 4 1 5 
i:1 
2 3 1 4 5 
i:2 
2 1 3 4 5 
i:3 
1 2 3 4 5 
----result------------
1 2 3 4 5 
-----------------
```

上面这个程序，奠定我下面代码的基础。中间交换用print_result1来打印，最后的结果用print_result来打印。

数组就用a表示，长度就用n。简洁一点。测试数组就是5个数字{5,2,4,3,1};

冒泡排序，从宏观效果上来看，每次有交换发生的时候，最小的元素就往前走了一位，就像水泡在水里往上浮动一样。

注意一点，外循环的i不会出现在内循环的里面。

交换只能发生在相邻的两个元素间。

第一个内循环完成，可以保证最大的元素已经到最后面了（升序排列时）。

# 快速排序

冒泡排序是相邻的两个元素进行比较和交互。每次只能移动一个位置。导致比较和移动的次数较多。

快速排序也叫分区交互排序。是对冒泡排序的改进。采用的算法思想是分治思想。

## 算法原理

1、从待排序的n个元素里，任意选取一个元素作为区分标准（通常是第一个元素）。

2、对所有小于该元素的排到左边，大于该元素的排在右边。这个是第一趟排序。

3、对左右的子序列分别重复上面的过程。直到排序完成。

使用了递归的方式来实现。



```
#include <stdio.h>

void quick_sort(int *a, int left, int right)
{
    if(left >= right)
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];
     
    while(i < j)
    {
        while(i < j && key <= a[j]){
            j--;
        }
        a[i] = a[j];
        while(i < j && key >= a[i]){
            i++;
        }
        a[j] = a[i];
    }
    a[i] = key;
    quick_sort(a, left, i - 1);
    quick_sort(a, i + 1, right);
}


void print_result(int a[], int n)
{
    int i=0;
    printf("----result------------\n");
    for(i=0; i<n; i++) {
        printf("%d ", a[i]);
    }
    printf("\n-----------------\n");
}
void main()
{
    int a[5] = {5,2,4,3,1};
    quick_sort(a,0,4);
    print_result(a, 5);
    
}
```



# 简单插入排序

## 原理

从待排序的n个元素里的第二个开始，依次跟前面的元素比较并且寻址插入的位置。



# 参考文章

1、十种常见排序算法

http://blog.csdn.net/k346k346/article/details/50791102