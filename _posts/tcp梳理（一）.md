---
title: tcp梳理（一）
date: 2018-03-12 10:06:20
tags:
	- 网络
	- tcp
typora-root-url: ..\

---



tcp也反反复复看了好多遍。现在把过程认真梳理一遍。

先来一个交互的图。

![tcp连接传输断开](/images/tcp连接传输断开.png)

对于上面的过程，一般初始化的时候，认为x=0，y=0 。







# 连接的3次握手

作用：

1、初始化seq number的值。这个要在后续的通信中作为序号使用。保证不会乱序。

# 断开的4次挥手

1、其实是2次。因为tcp是全双工的，所以发送方和接收方都要进行fin和ack。只不过有一方是被动的。

2、如果发送方和接收方同时

# 重传机制

ack只会认最后一个连续的包。例如发送方发了1到5共5份数据，接收方收到了1和2，回复发送方一个ack 3，但是却收到了4这个包。（说明中间的3这个包丢掉了）。

ack不能跳着确认，只能连续确认，不然就会认为前面的包都收到了。

下面就针对这个场景来看看各种重传怎么做。

## 超时重传

一种方式是，不会ack，一直等3，等发送方发现收不到3的ack的时候，就会重传3的。

而一旦接收方收到3，就会ack 4，因为之前4已经收到了。

这种方式有个问题，就是要死等3 ，而发送方不知道发生了什么。可能会导致4和5也要重传。

现在有2个选择：

```
1、只重传超时的包，也就是数据3 。节省带宽，但是慢。
2、重传之后的所有的包，也就是数据3/4/5 。快一点，但是没好多少。
```

可以看到，两种方法都不够好。所以就引入了新的算法。

## 快速重传机制

快速重传机制，不是靠时间驱动，而是靠数据驱动。

靠的就是ack的不能跳着确认的原理。

当包3丢了的时候，你给接收方发送任何数据，都会回复ack 2。

如果连续3次，发送方都收到ack 2，那么就可以去人包3丢掉了。可以重新发送包3了。

快速重传只解决了一个问题，就是timeout的问题。

它还是要面临一个艰难的选择：

是重传一个呢？还是重传所有？

所以，问题还需要继续解决。

## SACK

sack是选择性确认的意思。s是selective的意思。

这个需要在tcp头里加一个SACK的东西。

这个需要协议的通信双方都支持才行，linux从2.4以后就默认支持了。



## RTT算法

这个就是计算超时时间的。

timeout这个参数：

1、如果太长了，重发就慢。导致性能差。

2、如果太短了。可能导致误判断丢包。导致越发越丢包，越丢包越发的恶性循环。

这个参数其实是一个动态参数，会根据网络的质量动态调整的。

这个就是RTT算法。RTT是Round Trip Time。来回时间。

算法在RFC793里是这样描述的：

```
1、首先，采用RTT，记下最近的几次RTT值。
2、做平滑计算SRTT。S代表Smoothed。
一个加权移动平均参数，记为a。a在0.8到0.9之间。
公式是这样的：SRTT = (a * SRTT) + ((1 - a)*RTT)
3、计算RTO。超时时间。
引入参数b。b在1.3到2.0之间。
RTO = min[ubound, max[lbound, (b*SRTT)]]
ubound是最大的timeout值。
lbound是最小的timeout值。
```

# 窗口大小具体是指什么？

在TCP报头中，窗口字段是2字节，最大值65535，也就是缓冲区最大为16K字节。
窗口控制大小的目的不是为了控制“长度”，而是控制“速度”。

MTU

是链路层的限制，但是需要在网络层处理。

MSS

Max Segment Size。是网络层的限制，需要传输层进行处理。

指的是不包含tcp头和ip头的负载部分长度。

例如mtu为1500 ，那么MSS就是1500 - ip头（20字节）- tcp头（20字节）= 1460 字节。

如果是这样的两台机器进行通信。

```
A(MTU 1500) <---> B(MTU 1492)
```

建立tcp连接的过程中：

1、A告诉B，我的mss是1460 。

2、B告诉A，我的mss是1452 。

3、协商的结构是用二者的较小值，就是1452 。



如果A告诉B，自己的window是8192，意思就是，B最多可以连续给A发送8192个字节。

如果A告诉B，自己的window是0，那么B就不会给A发送数据。

一直A说自己的window是0的时候，是自己很忙，没空处理。

但是A不能一直说自己很忙。B怎么知道A已经不忙了呢？

这个就要借助一个坚持定时器。

坚持定时器时间到了，B就给A发送负载为1个字节的tcp数据。意思说，你现在有空了吗？

如果A还是很忙，则还是告诉B自己的window是0 。

坚持定时器的时间是1s、2s、4s、8s这样依次递增的。



# 参考文章

1、

https://link.zhihu.com/?target=http%3A//coolshell.cn/articles/11564.html

2、

http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm

3、请问TCP的窗口大小到底指的是什么？

https://zhidao.baidu.com/question/1641775096629872460.html

4、TCP流量控制中的滑动窗口大小、TCP字段中16位窗口大小、MTU、MSS、缓存区大小有什么关系

https://blog.csdn.net/scythe666/article/details/51967591



