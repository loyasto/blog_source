---
title: tcp梳理（一）
date: 2018-03-12 10:06:20
tags:
	- 网络
	- tcp
typora-root-url: ..\

---



tcp也反反复复看了好多遍。现在把过程认真梳理一遍。

先来一个交互的图。

![tcp连接传输断开](/images/tcp连接传输断开.png)

对于上面的过程，一般初始化的时候，认为x=0，y=0 。







# 连接的3次握手

作用：

1、初始化seq number的值。这个要在后续的通信中作为序号使用。保证不会乱序。

# 断开的4次挥手

1、其实是2次。因为tcp是全双工的，所以发送方和接收方都要进行fin和ack。只不过有一方是被动的。

2、如果发送方和接收方同时

# 重传机制

ack只会认最后一个连续的包。例如发送方发了1到5共5份数据，接收方收到了1和2，回复发送方一个ack 3，但是却收到了4这个包。（说明中间的3这个包丢掉了）。

ack不能跳着确认，只能连续确认，不然就会认为前面的包都收到了。

下面就针对这个场景来看看各种重传怎么做。

## 超时重传

一种方式是，不会ack，一直等3，等发送方发现收不到3的ack的时候，就会重传3的。

而一旦接收方收到3，就会ack 4，因为之前4已经收到了。

这种方式有个问题，就是要死等3 ，而发送方不知道发生了什么。可能会导致4和5也要重传。

现在有2个选择：

```
1、只重传超时的包，也就是数据3 。节省带宽，但是慢。
2、重传之后的所有的包，也就是数据3/4/5 。快一点，但是没好多少。
```

可以看到，两种方法都不够好。所以就引入了新的算法。

## 快速重传机制

快速重传机制，不是靠时间驱动，而是靠数据驱动。

靠的就是ack的不能跳着确认的原理。

当包3丢了的时候，你给接收方发送任何数据，都会回复ack 2。

如果连续3次，发送方都收到ack 2，那么就可以去人包3丢掉了。可以重新发送包3了。

快速重传只解决了一个问题，就是timeout的问题。

它还是要面临一个艰难的选择：

是重传一个呢？还是重传所有？

所以，问题还需要继续解决。

## SACK

sack是选择性确认的意思。s是selective的意思。

这个需要在tcp头里加一个SACK的东西。

这个需要协议的通信双方都支持才行，linux从2.4以后就默认支持了。



## RTT算法

这个就是计算超时时间的。

timeout这个参数：

1、如果太长了，重发就慢。导致性能差。

2、如果太短了。可能导致误判断丢包。导致越发越丢包，越丢包越发的恶性循环。

这个参数其实是一个动态参数，会根据网络的质量动态调整的。

这个就是RTT算法。RTT是Round Trip Time。来回时间。

算法在RFC793里是这样描述的：

```
1、首先，采用RTT，记下最近的几次RTT值。
2、做平滑计算SRTT。S代表Smoothed。
一个加权移动平均参数，记为a。a在0.8到0.9之间。
公式是这样的：SRTT = (a * SRTT) + ((1 - a)*RTT)
3、计算RTO。超时时间。
引入参数b。b在1.3到2.0之间。
RTO = min[ubound, max[lbound, (b*SRTT)]]
ubound是最大的timeout值。
lbound是最小的timeout值。
```



# 参考文章

1、

https://link.zhihu.com/?target=http%3A//coolshell.cn/articles/11564.html

2、

http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm